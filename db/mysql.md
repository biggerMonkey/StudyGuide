# 事务ACID

## 1.简述

| 名称               | 中文   | 含义                                                 | 示例 |
| ------------------ | ------ | ---------------------------------------------------- | ---- |
| A(**Atomicity**)   | 原子性 | 事务执行的最小单位，不可分割，要么都成功，要么都失败 |      |
| C(**Consistency**) | 一致性 | 事务执行前后，数据库的完整性没有被破坏               |      |
| I(**Isolation**)   | 隔离性 | 允许事务并发，同时事务之间互不影响                   |      |
| D(**Durability**)  | 持久性 | 事务提交完成后，对数据库中数据的影响是持久的         |      |

示例：

原子性：张三给李四转500，张三余额减少500，李四余额增加500，这两个操作必须同时成功或者同时失败

一致性：事务执行完成后，张三余额只能减少500，李四余额只能增加500

隔离性：在张三给李四转账时，王五也可以给赵六转钱，并且互不影响

持久性：事务执行完成后，数据库或者服务器宕机了，重启后，张三、李四的余额不发生变化

## 2.实现

[参考文档](https://www.cnblogs.com/mvpsjf773/p/15251917.html)

[mysql 三种log](https://segmentfault.com/a/1190000039715378)

### 2.1 原子性

使用 undo log 回滚日志 支持原子性

undo log 回滚日志的写入是在事务开始执行前就已经开始了；

undo log顾名思义，主要就是提供了回滚的作用，但其还有另一个主要作用，就是多个行版本控制(MVCC)，保证事务的原子性。在数据修改的流程中，会记录一条与当前操作相反的逻辑日志到undo log中

**MVCC**:

​		基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别提交读和可重复读有效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。

**实现逻辑：**

**InnoDB存储引擎在数据库每行数据的后面添加了三个字段**

- 6字节的事务ID(DB_TRX_ID)字段：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。
- 7字节的回滚指针(DB_ROLL_PTR)字段：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。
- 6字节的DB_ROW_ID字段：包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。

### 2.2 持久性

使用 redo log 重做日志 支持持久性

redo log重做日志，这个日志是由MySql的 *innodb存储引擎* 提供维护的，此日志文件只存在于innodb存储引擎下；

redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。



**刷盘配置**

- 0：表示事务提交时不进行写入重做日志擦操作，MySql会使用其后台线程每一秒将日志缓冲区中的重做日志写入到 OS cache（磁盘缓存），同时立即调用 fsync 操作将 OS cache 中的重做日志写入到磁盘文件中（刷盘）；
- 1：表示在事务提交时就会进行重做日志的写入操作，实时的将日志缓冲区中的重做日志写入到 OS cache（磁盘缓存），同时立即调用 fsync 操作将 OS cache 中的重做日志写入到磁盘文件中（刷盘）； *此值为默认值* ，因为当设置值为1时可以保证事务的ACID中的持久性；
- 2：表示在事务提交时就会进行重做日志的写入操作，但是只是将日志缓冲区中的重做日志写入到 OS cache（磁盘缓存），不会立即调用 fsync 操作进行刷盘，MySQL后面会主动将OS cache中的重做日志数据每秒批量进行一次刷盘； 选择此值时，mysql的并发性最好，但是存在风险，当操作系统一旦宕机，会丢数据，但是如果MySql数据库宕机的话，则不会丢失数据，因为数据保存在了OS cache中；

**如何保证事物完整性：**[参考链接](https://mp.weixin.qq.com/s/5i9wmJs4_Er7RaYfNnETyA)

1. **WAL**

   预写式日志

   顺序写日志比随机写数据块，虽然都是落盘，但是顺序比随机快

2. **两段式提交**

   为保证事物的完整性、持久性，先写redo日志、再写binlog，再commit

   同时为了保证写入顺序，mysql5.6之前，会进行加锁，从开始写redo日子到binlog日志写完

   但是由于存在两次fsync到磁盘，导致并发并能很低，因此出现：组提交

3. **组提交**

   讲两段式的一个锁粒度减少四个锁粒度，锁粒度减少了，等待的时间就变短了

   **第一阶段（prepare阶段）：**

   持有prepare_commit_mutex，并且write/fsync redo log到磁盘，设置为prepared状态，完成后就释放prepare_commit_mutex，binlog不作任何操作。

   **第二个阶段（commit阶段）**：这里拆分成了三步，每一步的任务分配给一个专门的线程处理：

   1. **Flush Stage（写入binlog缓存）**

      ① 持有Lock_log mutex [leader持有，follower等待]

      ② 获取队列中的一组binlog(队列中的所有事务)

      ③ 写入binlog缓存

   2. **Sync Stage（将binlog落盘）**

      ①释放Lock_log mutex，持有Lock_sync mutex[leader持有，follower等待]

      ②将一组binlog落盘（fsync动作，最耗时，假设sync_binlog为1）。

   3. **Commit Stage（InnoDB commit，清楚undo信息）**

      ①释放Lock_sync mutex，持有Lock_commit mutex[leader持有，follower等待]

      ② 遍历队列中的事务，逐一进行InnoDB commit

      ③ 释放Lock_commit mutex

   所有操作都经过队列保证顺序，同时可以批量处理，就可以提高效率

   **这个思想值得借鉴**

4. **数据恢复处理**

   1. **时刻A**（刚在内存中更改完数据页，还没有开始写redo log的时候奔溃）：

      因为内存中的脏页还没刷盘，也没有写redo log和binlog，即这个事务还没有开始提交，所以奔溃恢复跟该事务没有关系；

   2. **时刻B**（正在写redo log或者已经写完redo log并且落盘后，处于prepare状态，还没有开始写binlog的时候奔溃）：

      恢复后会判断redo log的事务是不是完整的，如果不是则根据undo log回滚；如果是完整的并且是prepare状态，则进一步判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log进行回滚；

   3. **时刻C**（正在写binlog或者已经写完binlog并且落盘了，还没有开始commit redo log的时候奔溃）：

      恢复后会跟时刻B一样，先检查redo log中是完整并且处于prepare状态的事务，然后判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log回滚，完整则重新commit redo log；

   4. **时刻D**（正在commit redo log或者事务已经提交完的时候，还没有反馈成功给客户端的时候奔溃）：

      恢复后跟时刻C基本一样，都会对照redo log和binlog的事务完整性，来确认是回滚还是重新提交。



### 2.3 隔离性

利用锁和MVCC机制保证隔离性

| 事务隔离级别                       | 脏读 | 不可重复读 | 幻读 |
| ---------------------------------- | ---- | ---------- | ---- |
| 读未提交(read-uncommited)          | 是   | 是         | 是   |
| 不可重复读(读已提交,read-commited) | 否   | 是         | 是   |
| 可重复读(repeatable-read)          | 否   | 否         | 是   |
| 串行化(serializable)               | 否   | 否         | 否   |

目前公司生产使用的是**RR**

原因：不会产生脏读，可重复读，同时在innoDb下，避免了幻读问题



- **未提交读（RU）** 所有事务都可以看到其他未提交事务的执行结果， 即在未提交读级别，事务的修改，即使没有提交，对其他事务也是可见的，该隔离级别很少使用到，也被称为脏读。

- **提交读（RC）** 大多数的数据库默认的隔离级别是 提交读，但是对于Mysql不是 提交读：一个事务开始时，只能“看见”已经提交的事物所做的修改。换句话说一个事务从开始直到提交之前，所做的任何修改都是对其他事务不可见的。这个级别也叫作不可重复读。

- **可重复读（RR）** 解决了脏读了问题，该级别保证了在同一个事务多次读取同样记录的结果是一致的。但是可重复读还是无法解决幻读的问题： 什么是幻读 指的是当某个事务在读取某个范围内的记录的时候，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时候 就会产生 幻行**。InnoDB 和XtraDB 存储引擎通过版本并发控制解决而了幻读的问题可重复读是Mysql的事务的默认隔离级别。**注意在 SQL标准中，RR是无法避免幻读问题，**但是InnoDB实现的RR避免了幻读问题。**

- **可串行化读** 是最高的隔离级别，通过强制事务串行化执行(即事务排队执行，不会出现并发)，避免了前面所说到的幻读的问题。就是可串行化 会在读取的每一行数据上都加上锁，但是这样会导致超时和锁争用问题。

  1. **脏读：事务A读取到事物B修改未提交的内容，然后事务B因为某些原因失败回滚，事务A读取到的数据是无效数据，也就是脏数据
  2. **不可重复读：**事务A读取记录1，事务B修改记录1，事务A再次读记录1时，发现和第一次读取不一致，也就是不可重复读
  3. **幻读：**事务A读使用where条件读取多条记录，事务B插入一条新纪录刚好满足事务A的where条件，导致事务A再次以相同条件读取时可以读取到事务B新插入的数据，事务B新插入的记录就是幻读

  

  在两个update/delete时，更新相同记录，会被锁住，等待其他事务提交之后才能继续更新，同时也会看到其他事务的更新结果，但是查询是其他事务更新提交事情的数据

  

### 2.4 一致性